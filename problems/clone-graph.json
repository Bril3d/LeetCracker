{"problemName":"clone-graph","language":"cpp","code":"/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    void dfs(Node* node, unordered_map<int, Node*> &umap, unordered_map<int, int> &vis){\n        // cout<<node->val<<endl;\n        vis[node->val] = 1;\n        for(auto i : node->neighbors){\n            if(vis[i->val])continue;\n            vis[i->val] = 1;\n            if(umap.count(i->val) > 0){\n                dfs(i, umap, vis);\n            }else{\n                Node *newNode = new Node(i->val);;\n                umap[i->val] = newNode;\n                dfs(i, umap, vis);\n            }\n        }\n    }\n    void dfs(Node *node, Node *newNode, unordered_map<int, Node*> &umap, unordered_map<int, int> &vis){\n        vis[node->val] = 1;\n        for(auto i : node->neighbors){\n            newNode->neighbors.push_back(umap[i->val]);\n            if(vis[i->val])continue;\n            vis[i->val] = 1;\n            dfs(i, umap[i->val], umap,  vis);\n        }\n    }\n    Node* cloneGraph(Node* node) {\n        if(node == NULL) return NULL;\n        unordered_map<int, Node*> umap;\n        Node *newNode = new Node(node->val);\n        umap[node->val] = newNode;\n        \n        unordered_map<int, int> vis;\n        dfs(node, umap, vis);\n        vis.clear();\n        dfs(node, newNode, umap, vis);\n        return newNode;\n    }\n};"}