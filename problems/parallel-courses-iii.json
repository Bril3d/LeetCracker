{"problemName":"parallel-courses-iii","language":"cpp","code":"class Solution {\npublic:\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\n        map<int, vector<int> > g;\n        vector<int> dist(n + 1, 0);\n        vector<int> in_deg(n + 1, 0);\n        queue<int> q;\n        for(auto i : relations) {\n            g[i[0]].push_back(i[1]);\n            in_deg[i[1]]++;\n        }\n        for(int i = 1; i <= n; i++) {\n            if(in_deg[i] == 0) {\n                q.push(i);\n            }\n            dist[i] = time[i-1];\n        }\n        int ans = 0;\n        \n        while(!q.empty()) {\n                int node = q.front();\n                q.pop();\n                \n                for(auto c : g[node]) {\n                    dist[c] = max(dist[c], dist[node] + time[c - 1]);\n                    in_deg[c]--;\n                    if(in_deg[c] == 0) {\n                        q.push(c);\n                    }\n                }\n        }\n        \n        return *max_element(dist.begin(), dist.end());\n    }\n};"}