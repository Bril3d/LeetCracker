{"problemName":"smallest-range-covering-elements-from-k-lists","language":"cpp","code":"class Solution {\npublic:\n    bool helper(int a,int b,int x,int y){\n        if(a==INT_MAX||b==INT_MAX) return 1;\n        if(b-a==y-x) return x<a;\n        return y-x<b-a;\n    }\n    vector<int> smallestRange(vector<vector<int>>& nums) {\n        vector<pair<int,int>> vec;\n        int mark=0;\n        for(auto i:nums){\n            for(auto ii:i){\n                vec.push_back({ii,mark});\n            }\n            mark++;\n        }\n        sort(begin(vec),end(vec));\n        // for(auto i:vec) cout<<i.first<<\" \"<<i.second<<endl;\n        cout<<endl;\n        unordered_map<int,int> umap;\n        int i=0,j=0;\n        umap[vec[i].second]++;\n        int left=INT_MAX,right=INT_MAX;\n        int mn=INT_MAX;\n        while(j<vec.size()){\n            \n            if(i<=j&&umap.size()>=nums.size()){\n                cout<<vec[i].first<<\" \"<<vec[j].first<<\" \"<<umap.size()<<endl; \n                if(mn>=vec[j].first-vec[i].first+1&&helper(left,right,vec[i].first,vec[j].first)){\n                    left=vec[i].first;\n                    right=vec[j].first;\n                    mn=right-left+1;\n                }\n                umap[vec[i].second]--;\n                if(umap[vec[i].second]==0) umap.erase(vec[i].second);\n                i++;\n            }else{\n                j++;\n                if(j<vec.size())\n                    umap[vec[j].second]++;\n            }\n        }\n\n        return {left,right};\n\n\n\n    }\n};"}