{"problemName":"recover-a-tree-from-preorder-traversal","language":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* recoverFromPreorder(string traversal) {\n        vector<pair<int, int>> arr;\n        int cnt = 0;\n        int num = 0;\n        for(auto i : traversal){\n            if(i >='0' && i<='9'){\n                num = num * 10 + i - '0';\n            }else{\n                if(num != 0){\n                    arr.push_back({cnt, num});\n                    num = 0;\n                    cnt = 0;\n                }\n                cnt++;\n            }\n        }\n        if(num != 0){\n            arr.push_back({cnt, num});\n        }\n        map<TreeNode *, TreeNode *> mp;\n        TreeNode *root = new TreeNode(arr[0].second);\n        TreeNode *temp = root;\n        mp[root] = NULL;\n        int prev = 0;\n        for(int i = 1; i < arr.size(); i++){\n            while(prev >= arr[i].first){\n                prev--;\n                temp = mp[temp];\n            }\n            TreeNode *t = new TreeNode(arr[i].second);\n            mp[t] = temp;\n            if(temp->left == NULL)\n                temp->left = t;\n            else\n                temp->right = t;\n            temp = t;\n            prev = arr[i].first; \n        }\n        // for(auto i : arr){\n        //     cout<<i.first<<\", \"<<i.second<<endl;\n        // }\n        return root;\n    }\n};"}