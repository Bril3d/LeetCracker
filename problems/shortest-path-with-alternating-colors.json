{"problemName":"shortest-path-with-alternating-colors","language":"cpp","code":"class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {\n        unordered_map<int,vector<pair<int,int>> > umap;\n        for(auto a:redEdges) umap[a[0]].push_back({a[1],0});\n        for(auto a:blueEdges) umap[a[0]].push_back({a[1],1});\n\n        unordered_map<int,int> distance;\n        for(int i=0;i<n;i++) distance[i]=INT_MAX;\n        queue<pair<int,int>> que;\n        que.push({0,-1});\n        distance[0]=0;\n        set<pair<int,int>> st;\n        st.insert({0,-1});\n\n        int dist=0;\n        while(que.size()){\n            int size=que.size();\n            while(size--){\n                auto tp=que.front();\n                que.pop();\n                \n                for(auto ngh:umap[tp.first]){\n                    if(ngh.second!=tp.second&&!st.count({ngh.first,ngh.second})){\n                        distance[ngh.first]=min(distance[ngh.first],dist+1);\n                        st.insert({ngh.first,ngh.second});\n                        que.push({ngh.first,ngh.second});\n                    }\n                }\n            }\n            dist++;\n        }\n        vector<int> ans(n,-1);\n        for(auto i:distance){\n            ans[i.first]=(i.second==INT_MAX)?-1:i.second;\n        }\n        return ans;\n\n    }\n};"}