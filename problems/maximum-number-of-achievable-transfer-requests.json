{"problemName":"maximum-number-of-achievable-transfer-requests","language":"cpp","code":"class Solution {\npublic:\n    void backtrack(vector<vector<int>>& requests, int index, vector<int>& count, int currCount, int& maxCount) {\n        // Base case: If all requests have been processed\n        if (index == requests.size()) {\n            // Check if all buildings have a balanced count\n            for (int i = 0; i < count.size(); i++) {\n                if (count[i] != 0) return; // Some building is unbalanced, return\n            }\n            // Update the maximum count if the current count is greater\n            maxCount = max(maxCount, currCount);\n            return;\n        }\n\n        // Process the current request\n        int from = requests[index][0];\n        int to = requests[index][1];\n        count[from]--; // Decrease count of \"from\" building\n        count[to]++;   // Increase count of \"to\" building\n\n        // Recursively process the next request with the current count incremented\n        backtrack(requests, index + 1, count, currCount + 1, maxCount);\n\n        // Undo the previous changes (backtracking)\n        count[from]++; // Undo count change for \"from\" building\n        count[to]--;   // Undo count change for \"to\" building\n\n        // Recursively process the next request with the current count\n        backtrack(requests, index + 1, count, currCount, maxCount);\n    }\n\n    int maximumRequests(int n, vector<vector<int>>& requests) {\n        vector<int> count(n); // Initialize count of buildings to 0\n        int maxCount = 0;     // Maximum count of balanced requests\n        backtrack(requests, 0, count, 0, maxCount); // Start backtracking from index 0\n        return maxCount;     // Return the maximum count\n    }\n};"}