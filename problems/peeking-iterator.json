{"problemName":"peeking-iterator","language":"cpp","code":"/*\n * Below is the interface for Iterator, which is already defined for you.\n * **DO NOT** modify the interface for Iterator.\n *\n *  class Iterator {\n *\t\tstruct Data;\n * \t\tData* data;\n *  public:\n *\t\tIterator(const vector<int>& nums);\n * \t\tIterator(const Iterator& iter);\n *\n * \t\t// Returns the next element in the iteration.\n *\t\tint next();\n *\n *\t\t// Returns true if the iteration has more elements.\n *\t\tbool hasNext() const;\n *\t};\n */\nclass Node{\npublic:\n    int val;\n    Node *next;\n    Node(int _val){\n        val = _val;\n        next = NULL;\n    }\n};\nclass PeekingIterator : public Iterator {\npublic:\n    Node *head = NULL;\n\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\n        head = new Node(nums[0]);        \n        Node *temp = head;\n        for(int i = 1; i < nums.size(); i++){\n            temp->next = new Node(nums[i]);\n            temp = temp->next;\n        }\t    \n\t}\n\t\n    // Returns the next element in the iteration without advancing the iterator.\n\tint peek() {\n        return head->val;\n\t}\n\t\n\t// hasNext() and next() should behave the same as in the Iterator interface.\n\t// Override them if needed.\n\tint next() {\n        if(head != NULL){\n            Node *temp = head;\n            head = head->next;\n            return temp->val;\n        }else{\n            return -1;\n        }\n\t}\n\t\n\tbool hasNext() const {\n        if(head == NULL)return false;\n        return true;\n\t}\n};"}