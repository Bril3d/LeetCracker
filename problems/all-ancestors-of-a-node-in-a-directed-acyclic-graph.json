{"problemName":"all-ancestors-of-a-node-in-a-directed-acyclic-graph","language":"cpp","code":"class Solution {\npublic:\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\n        //stores vector of adjacency list with each node having a vector of nodes to which it points \n        vector<int> adj_list[n];   \n        \n        //stores indegree of each node\n        vector<int> indegree(n);\n        \n        //creating adjacency list and updating indegrees\n        for(int i=0;i<edges.size();++i)\n        {\n            adj_list[edges[i][0]].push_back(edges[i][1]);\n            indegree[edges[i][1]]++;\n        }\n        \n        //queue for BFS Traversal\n        queue<int> q; \n        \n        //adding all the nodes with indegree==0 as they act as the source node\n        for(int i=0;i<n;++i)\n        {\n            if(indegree[i]==0)\n                q.push(i);\n        }\n        \n        set<int> st[n]; //to avoid repetition of parent nodes \n        while(!q.empty())\n        {\n            \n            int cur=q.front(); \n            q.pop();\n            \n            for(auto it:adj_list[cur])\n            {\n                //inserting immediate parent node to each child of current node\n                st[it].insert(cur); \n                \n                //adds all the ancestors of the current node\n                for(auto it2:st[cur])\n                    st[it].insert(it2);\n                 \n                //adding to queue if indegree ==0\n                indegree[it]--;\n                if(indegree[it]==0)\n                q.push(it);\n            }\n        }\n        \n        //to store ans\n        vector<vector<int>> ans(n,vector<int>());\n        \n        //adding ancestors of each node to final ans vector\n        for(int i=0;i<n;++i)\n            ans[i]=vector<int>(st[i].begin(),st[i].end());\n        \n        \n        return ans; \n    }\n};"}