{"problemName":"minimum-cost-to-merge-stones","language":"cpp","code":"class Solution {\npublic:\n    int dp[50][50][50];\n    int helper(vector<int>& stones,vector<int> &pre, int i,int j,int piles,int k){\n        if(i==j&&piles==1) return 0;\n        if(i==j) return INT_MAX/4;\n        \n        if(dp[i][j][piles]!=-1) return dp[i][j][piles];\n        if(piles==1){\n            return dp[i][j][piles]=helper(stones,pre,i,j,k,k)+((i!=0)? pre[j]-pre[i-1]:pre[j]);\n        }\n        int ans=INT_MAX/4;\n        for(int ii=i;ii<j;ii++){\n            ans=min(ans,helper(stones,pre,i,ii,1,k)+helper(stones,pre,ii+1,j,piles-1,k));\n        }\n        return dp[i][j][piles]=ans;\n    }\n    int mergeStones(vector<int>& stones, int k) {\n        if((stones.size()-1)%(k-1)!=0)\n            return -1;\n         int sum = 0;\n        vector<int>pre;\n        for(int i=0;i<stones.size();i++){\n            sum+=stones[i];\n            pre.push_back(sum);\n        }\n        memset(dp,-1,sizeof(dp));\n        return helper(stones,pre,0,stones.size()-1,1,k);\n        \n    }\n};"}