{"problemName":"smallest-sufficient-team","language":"cpp","code":"class Solution {\npublic:\n\nvector<int>res;\n\nvoid helper(int i,vector<int>&people_skill,int m,int mask,vector<int>&ans,vector<vector<int>>&dp)\n{\n  if(i == people_skill.size()) //Base Case\n  {\n    if(mask == ((1<<m)-1)) //Check for all req_skills included\n    {\n      if(res.size() == 0 || (ans.size() < res.size())) res = ans; //better ans then update\n    }\n    return;\n  }\n\n  if(dp[i][mask] != -1) //Memoization Part\n  {\n    if(dp[i][mask] <= ans.size()) return;\n  }\n\n  helper(i+1,people_skill,m,mask,ans,dp); //Non-Pick / Ignore Case\n\n  ans.push_back(i); // Pick Case\n\n  helper(i+1,people_skill,m,(mask|people_skill[i]),ans,dp); //Next Call\n\n  ans.pop_back(); //Undo the change in Pick\n\n  if(ans.size() > 0) dp[i][mask] = ans.size(); //if found and answer then update DP\n}\n\n\n vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {\n\n        int n = people.size();\n        int m = req_skills.size();\n\n        unordered_map<string,int>mpp; //for hashing skill v/s bit\n\n        for(int i = 0;i<m;++i) mpp[req_skills[i]] = (1<<i); //setting ith bit, for req_skill[i] skill\n\n        vector<int>people_skill; //vector of mask for peoples\n\n        for(auto it : people) \n        {\n          int mask = 0;\n          for(int j = 0; j < it.size(); ++j)\n          {\n            if(mpp.count(it[j])) mask |= mpp[it[j]]; //if it[j] is a required skill then set that bit for that people's mask\n          }\n          people_skill.push_back(mask); //store the mask \n        }\n\n        vector<vector<int>> dp(n, vector<int>((1<<m),-1)); //n=number of people, and (1<<m) to express all value mask of size m can take\n        vector<int>ans;\n\n        helper(0,people_skill,m,0,ans,dp);\n        return res;\n    }\n};"}