{"problemName":"smallest-string-with-swaps","language":"cpp","code":"class Solution {\npublic:\n    // Maximum number of vertices\n    static const int N = 100001;\n    vector<int> adj[N];\n    bool visited[N];\n    \n    void DFS(string& s, int vertex, vector<char>& characters, vector<int>& indices) {\n        // Add the character and index to the list\n        characters.push_back(s[vertex]);\n        indices.push_back(vertex);\n        \n        visited[vertex] = true;\n        \n        // Traverse the adjacents\n        for (int adjacent : adj[vertex]) {\n            if (!visited[adjacent]) {\n                DFS(s, adjacent, characters, indices);\n            }\n        }\n    }\n    \n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\n        // Build the adjacency list\n        for (vector<int> edge : pairs) {\n            int source = edge[0];\n            int destination = edge[1];\n            \n            // Undirected edge\n            adj[source].push_back(destination);\n            adj[destination].push_back(source);\n        }\n        \n        for (int vertex = 0; vertex < s.size(); vertex++) {\n            // If not covered in the DFS yet\n            if (!visited[vertex]) {\n                vector<char> characters;\n                vector<int> indices;\n                \n                DFS(s, vertex, characters, indices);\n                // Sort the list of characters and indices\n                sort(characters.begin(), characters.end());\n                sort(indices.begin(), indices.end());\n\n                // Store the sorted characters corresponding to the index\n                for (int index = 0; index < characters.size(); index++) {\n                    s[indices[index]] = characters[index];\n                }\n            }\n        }\n        \n        return s;\n    }\n};"}