{"problemName":"palindrome-pairs","language":"cpp","code":"struct TrieNode {\n    TrieNode *next[26] = {};\n    int index = -1;\n    vector<int> palindromeIndexes;\n};\n\nclass Solution {\n    TrieNode root; // Suffix trie\n    void add(string &s, int i) {\n        auto node = &root;\n        for (int j = s.size() - 1; j >= 0; --j) {\n            if (isPalindrome(s, 0, j)) node->palindromeIndexes.push_back(i); // A[i]'s prefix forms a palindrome\n            int c = s[j] - 'a';\n            if (!node->next[c]) node->next[c] = new TrieNode();\n            node = node->next[c];\n        }\n        node->index = i;\n        node->palindromeIndexes.push_back(i); // A[i]'s prefix is empty string here, which is a palindrome.\n    }\n    \n    bool isPalindrome(string &s, int i, int j) {\n        while (i < j && s[i] == s[j]) ++i, --j;\n        return i >= j;\n    }\n    \npublic:\n    vector<vector<int>> palindromePairs(vector<string>& A) {\n        int N = A.size();\n        for (int i = 0; i < N; ++i) add(A[i], i);\n        vector<vector<int>> ans;\n        for (int i = 0; i < N; ++i) {\n            auto s = A[i];\n            auto node = &root;\n            for (int j = 0; j < s.size() && node; ++j) {\n                if (node->index != -1 && node->index != i && isPalindrome(s, j, s.size() - 1)) ans.push_back({ i, node->index }); \n                // A[i]'s prefix matches this word and A[i]'s suffix forms a palindrome\n                node = node->next[s[j] - 'a'];\n            }\n            if (!node) continue;\n            for (int j : node->palindromeIndexes) { \n                // A[i] is exhausted in the matching above. \n                // If a word whose prefix is palindrome after matching its suffix with A[i], \n                // then this is also a valid pair\n                if (i != j) ans.push_back({ i, j });\n            }\n        }\n        return ans;\n    }\n};"}