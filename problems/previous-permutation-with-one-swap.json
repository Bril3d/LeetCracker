{"problemName":"previous-permutation-with-one-swap","language":"cpp","code":"class Solution {\npublic:\n    \n    vector<int> prevPermOpt1(vector<int>& A) {\n        int len = A.size();\n        if (len<2 || is_sorted(A))\n            return A;\n        \n        int cand = len-2;\n        while (cand>=0 && A[cand+1]>=A[cand]){\n            cand--;\n        }\n        \n        int sw =swap_with (A, cand+1);\n        swap (A[cand], A[sw]);\n        return A;\n        \n    }\n    \n    int swap_with(vector<int> &A, int left){\n        int right= A.size()-1;\n        int val = A[left-1];\n        int res= left;  \n        while (left<=right){\n            int mid = left+ (right-left)/2;           \n            if (A[mid]<val){           \n               if (A[res]<A[mid]) /*the preference for candid_2 is to be on left side as discussed by second example*/\n                 res= mid;\n               left=mid+1;\n            } else\n                right = mid-1;\n        }\n        \n        return res;\n    }\n    bool is_sorted(vector<int> &A){\n        for (int i= 1; i<A.size()-1;++i){\n            if (A[i-1]>A[i])\n                return false;\n        }\n        return true;\n    }\n};"}