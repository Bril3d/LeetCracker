{"problemName":"shortest-bridge","language":"cpp","code":"class Solution {\npublic:\nvector<int> d4 = {-1, 0, 1, 0, -1};\n    void dfs(vector<vector<int>> &grid, vector<vector<int>> &vis,queue<pair<int, int>> &q, int x, int y){\n        vis[x][y] = 1;\n        q.push({x, y});\n        for(int i = 0; i < 4; i ++){\n            int _x = x + d4[i], _y = y + d4[i + 1];\n            if(_x >=0 && _x< grid.size() && _y>=0 && _y< grid[0].size() && grid[_x][_y] == 1 && !vis[_x][_y]){\n                dfs(grid, vis, q, _x, _y);\n            }\n        }\n    }\n    int shortestBridge(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid.size();\n        vector<vector<int>> vis(n, vector<int> (m, 0));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m; j++){\n                if(grid[i][j] == 0)continue;\n                queue<pair<int, int>> q;\n                dfs(grid, vis, q, i, j);\n                int level = 0;\n                while(!q.empty()){\n                    level++;\n                    int sz = q.size();\n                    for(int k = 0; k < sz; k++){\n                        auto f = q.front();\n                        q.pop();\n                        for(int l = 0; l < 4; l++){\n                            int _x = f.first + d4[l], _y = f.second + d4[l + 1];\n                            if(_x >=0 && _x< grid.size() && _y>=0 && _y< grid[0].size()&& !vis[_x][_y]){\n                                if(grid[_x][_y] == 1)return level - 1;\n                                vis[_x][_y] = 1;\n                                q.push({_x, _y});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n};"}