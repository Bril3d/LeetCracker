{"problemName":"lexicographically-smallest-equivalent-string","language":"cpp","code":"class dsu {\n\n    vector<int> parent;\n    vector<int> size;\npublic:\n    dsu(int n) {\n        parent.resize(n);\n        size.resize(n);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n \n    int get(int v) {\n        if (parent[v] == v) {\n            return v;\n        }\n        return parent[v] = get(parent[v]);\n    }\n\n    void union_set(int a, int b) {\n        int spa = get(a);\n        int spb = get(b);\n        if (spa != spb) {\n            if (spa > spb) {\n                swap(spa, spb);\n            }\n            size[spa]  += size[spb];\n            size[spb] = 0;\n\n            parent[spb] = spa;\n        }\n        else {\n            if (size[spa] <  size[spb]) {\n                swap(spa, spb);\n            }\n            size[spa]++;\n\n        }\n    }\n};\n\n\nclass Solution {\npublic:\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\n\n        dsu g(27);\n        for(int i = 0; i < s1.size(); i++) {\n            g.union_set(s1[i] - 'a', s2[i] - 'a');\n        }\n\n        for(int i = 0; i < baseStr.size(); i++) {\n            baseStr[i] = g.get(baseStr[i] - 'a') + 'a';\n        }\n\n        return baseStr;\n\n\n        \n    }\n};"}