{"problemName":"profitable-schemes","language":"cpp","code":"class Solution {\npublic:\n    const int MOD = 1e9 + 7;\n    int dp[101][101][101];\n    long helper(vector<int> &group, vector<int> &profits, int n, int p, int ind){\n        if(n < 0)return 0;\n        if(ind == profits.size()){\n            if(p == 0)return 1;\n            return 0;\n        }\n        if(dp[n][p][ind] != -1)return dp[n][p][ind];\n        long  take = helper(group, profits, n - group[ind], max(0,p - profits[ind]), ind + 1);\n        long notTake = helper(group, profits, n, p, ind + 1);\n        return dp[n][p][ind] = ((take%MOD) + (notTake%MOD))%MOD;\n    }\n    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {\n        memset(dp, -1, sizeof dp);\n        return helper(group, profit, n, minProfit, 0)%MOD;\n    }\n};"}