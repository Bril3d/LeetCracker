{"problemName":"nearest-exit-from-entrance-in-maze","language":"cpp","code":"class Solution {\npublic:\n    int nearestExit(vector<vector<char>>& m, vector<int>& e) {\n        \n        queue<vector<int> > q;\n        q.push(e);\n        map<vector<int>, bool> vis;\n        vis[e] = true;\n        int cnt = 0;\n        while(!q.empty()) {\n            int size = q.size();\n            \n            while(size--) {\n                auto f  = q.front();\n                q.pop();\n                if(f != e) {\n                    if(f[0] == m.size() - 1 || f[1] == m[0].size() - 1 || f[0] == 0 || f[1] == 0) {\n                        return cnt;\n                    }\n                }\n                if(f[0] + 1 < m.size() and !vis[{f[0] + 1, f[1]}] and m[f[0] + 1][f[1]]  == '.') {\n                    q.push({f[0] + 1, f[1]});\n                    vis[{f[0] + 1, f[1]}] = true;\n                }\n                if(f[0] - 1 >= 0 and !vis[{f[0] - 1, f[1]}]  and m[f[0] - 1][f[1]]  == '.') {\n                    q.push({f[0] - 1, f[1]});\n                    vis[{f[0] - 1, f[1]}] = true;\n                }\n                if(f[1] + 1 < m[0].size() and !vis[{f[0], f[1] + 1}] and m[f[0]][f[1] + 1]  == '.') {\n                    q.push({f[0], f[1] + 1});\n                    vis[{f[0], f[1] + 1}] = true;\n                }\n                if(f[1] - 1 >= 0 and !vis[{f[0], f[1] - 1}] and m[f[0]][f[1] - 1]  == '.') {\n                    q.push({f[0], f[1] - 1});\n                    vis[{f[0], f[1] - 1}] = true;\n                }\n            }\n            cnt++;\n        }\n        return  -1;\n        \n    }\n};"}