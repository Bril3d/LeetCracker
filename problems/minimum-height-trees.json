{"problemName":"minimum-height-trees","language":"cpp","code":"class Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if(n==0)\n            return {};\n        if(n==1)\n            return {0};\n        vector<int>res;\n        vector<int>degrees(n,0);\n        vector<vector<int>>adj(n);\n        for(int i=0;i<edges.size();i++)\n        {\n            adj[edges[i][0]].push_back(edges[i][1]);//creating adjacent list\n            adj[edges[i][1]].push_back(edges[i][0]);\n            degrees[edges[i][1]]++;//updating how many edges each node has\n            degrees[edges[i][0]]++;\n        }\n        queue<int>queue;\n        for(int i=0;i<n;i++)\n        {\n            if(degrees[i]==1)//adding all the leave nodes\n                queue.push(i);\n        }\n        while(!queue.empty())\n        {\n            res.clear();// clear vector before we start traversing level by level.\n            int size=queue.size();\n            for(int i=0;i<size;i++)\n            {\n                int cur=queue.front();\n                queue.pop();\n                res.push_back(cur);//adding nodes to vector.Goal is to get a vector of  just 1 or 2 nodes available.\n                for(auto &neighbor:adj[cur])\n                {\n                    degrees[neighbor]--;//removing current leave nodes\n                    if(degrees[neighbor]==1)//adding current leave nodes\n                        queue.push(neighbor);\n                }\n            }\n        }\n        return res;\n    }\n};\n"}