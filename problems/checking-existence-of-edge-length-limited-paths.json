{"problemName":"checking-existence-of-edge-length-limited-paths","language":"cpp","code":"static class DSU {\n    vector<int> Parent, Rank;\n    public:\n    DSU(int n) {\n        Parent.resize(n);\n        Rank.resize(n, 0);\n        for (int i = 0; i < n; i++) Parent[i] = i;\n    }\n    int Find(int x) {\n        return Parent[x] = Parent[x] == x ? x : Find(Parent[x]);\n    }\n    bool Union(int x, int y) {\n        int xset = Find(x), yset = Find(y);\n        if (xset != yset) {\n            Rank[xset] < Rank[yset] ? Parent[xset] = yset : Parent[yset] = xset;\n            Rank[xset] += Rank[xset] == Rank[yset];\n            return true;\n        }\n        return false;\n    }\n};\nclass Solution {\npublic:\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries)\n    {\n        DSU dsu(n);\n        for(int i=0;i<queries.size();i++)\n            queries[i].push_back(i);\n\t\t\n        sort(queries.begin(), queries.end(), [](auto &l, auto &r) { return l[2] < r[2]; });\n        sort(edgeList.begin(), edgeList.end(), [](auto &l, auto &r) { return l.back() < r.back(); });\n        int i=0;\n        vector<bool> result(queries.size());\n        for (vector<int> &q:queries) \n        {\n            while (i<edgeList.size()&&edgeList[i][2]<q[2]) \n                dsu.Union(edgeList[i][0],edgeList[i++][1]);\n            result[q.back()]=dsu.Find(q[0]) == dsu.Find(q[1]);\n        }\n        return result;\n    }\n};"}