{"problemName":"minimum-time-to-collect-all-apples-in-a-tree","language":"cpp","code":"class Solution {\npublic:\n    bool helper(unordered_map<int,vector<int>>& umap,int curr,vector<int>&vec,unordered_set<int> &vis,vector<bool>& hasApple){\n        vis.insert(curr);\n        bool ans=hasApple[curr];\n        for(auto ngh:umap[curr]){\n            if(!vis.count(ngh)){\n                ans|=helper(umap,ngh,vec,vis,hasApple);\n            }\n        }\n        return vec[curr]=ans;\n    }\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<int> vec(n,0);\n        unordered_map<int,vector<int>> umap;\n        for(auto i:edges){\n            umap[i[0]].push_back(i[1]);\n            umap[i[1]].push_back(i[0]);\n        }\n\n        unordered_set<int> vis;\n        helper(umap,0,vec,vis,hasApple);\n\n\n        queue<int> que;\n        vis.clear();\n        if(vec[0]){\n            que.push(0);\n            vis.insert(0);\n        }\n        int ans=0;\n        while(que.size()){\n            int size=que.size();\n            while(size--){\n                int ft=que.front();\n                que.pop();\n                vis.insert(ft);\n                for(auto ngh:umap[ft]){\n                    if(!vis.count(ngh)&&vec[ngh]){\n                       ans+=2;\n                       que.push(ngh);\n                        \n                    }\n                }\n            }\n        }\n        return ans;\n    }\n\n\n};\n\n\n"}