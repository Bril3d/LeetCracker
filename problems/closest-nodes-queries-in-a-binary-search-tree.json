{"problemName":"closest-nodes-queries-in-a-binary-search-tree","language":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void helper(TreeNode* root,vector<int> &vec){\n        if(!root) return ;\n        vec.push_back(root->val);\n        helper(root->left,vec);\n        helper(root->right,vec);\n    }\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& q) {\n        vector<int> vec;\n        helper(root,vec);\n        \n        sort(begin(vec),end(vec));\n        vector<int> vecneg=vec;\n        for(auto &i:vecneg){\n            i=-i;\n        }\n        \n        sort(begin(vecneg),end(vecneg));\n        \n        vector<vector<int>> ans;\n        for(auto i:q){\n            int mx,mn;\n            \n            int k=lower_bound(vec.begin(), vec.end(), i)-begin(vec);\n            // cout<<k<<endl;\n            \n            \n            if(k>vec.size()-1){\n                mx=-1;\n                mn=vec.back();\n                ans.push_back({mn,mx});\n                continue;\n                \n            }\n            \n            if(vec[k]==i)mn=i;\n            else if(k!=0)mn=vec[k-1];\n            else mn=-1;\n            \n            if(vec[vec.size()-1]<i) mx=-1;\n            else mx=vec[k];\n            \n            ans.push_back({mn,mx});\n        }\n        return ans;\n    }\n};"}