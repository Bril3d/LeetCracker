{"problemName":"minimum-jumps-to-reach-home","language":"cpp","code":"class Solution {\npublic:\n    int findMinJump(unordered_map<int,int>& forbiddenMap,int a,int b,int x){\n        queue<pair<int,int>> que;\n        que.push({0,0});\n        int ans=0;\n        unordered_map<string,bool> visited;\n        visited[to_string(0)+\" \"+to_string(0)]=1;\n        while(que.size()){\n            int size=que.size();\n            while(size--){\n                \n                int curr_num=que.front().first;\n                int direction=que.front().second;\n                \n                \n                que.pop();\n                if(curr_num==x) return ans;\n                \n                if(direction==1 && curr_num-b>=0 && curr_num-b<=10000&& !forbiddenMap[curr_num-b]&&!visited[to_string(curr_num-b)+\" \"+to_string(0)]){\n                    \n                    visited[to_string(curr_num-b)+\" \"+to_string(0)]=1;\n                    que.push({curr_num-b,0});\n                }\n                if(!forbiddenMap[curr_num+a]&&curr_num+a<=10000&&curr_num+a>=0&&!visited[to_string(curr_num+a)+\" \"+to_string(1)]){\n                    // cout<<to_string(curr_num-b)+\",\"+to_string(0)<<\" \";\n                    visited[to_string(curr_num+a)+\" \"+to_string(1)]=1;\n                    que.push({curr_num+a,1});\n                }\n            }\n            ans++;\n        }\n        return -1;\n    }\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\n        unordered_map<int,int> forbiddenMap;\n        for(auto i:forbidden){\n            if(i==x) return -1;\n            forbiddenMap[i]++;\n        }\n        return findMinJump(forbiddenMap,a,b,x);\n        \n    }\n};"}