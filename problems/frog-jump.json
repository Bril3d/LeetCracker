{"problemName":"frog-jump","language":"cpp","code":"class Solution {\npublic:\n    unordered_map<string,int> dp;\n    bool helper(vector<int> &vec, unordered_map<int,int> &umap,int i, long long prev){\n        if(i>=vec.size()||i<0) return 0;\n        if(i==vec.size()-1) return 1;\n        string key=to_string(i)+\" \"+to_string(prev);\n        if(dp.count(key)){\n            return dp[key];\n        }\n        \n        bool ans=0;\n        long long k= prev+1;\n        if(umap.count(vec[i]+k)){\n            ans|=helper(vec,umap,umap[vec[i]+k],k);\n        }\n        k=prev-1;\n        if(umap.count(vec[i]+k)&& k>1){\n            ans|=helper(vec,umap,umap[vec[i]+k],k);\n        }\n        k=prev;\n        if(umap.count(vec[i]+k)){\n            ans|=helper(vec,umap,umap[vec[i]+k],k);\n        }\n\n        return dp[key]=ans;\n    }\n    bool canCross(vector<int>& s) {\n        if(s.size()==1) return 1;\n       unordered_map<int,int> st;\n        for(int i=0;i<s.size();i++){\n            st[s[i]]=i;\n        }\n        if(s[1]!=s[0]+1) return 0;\n        return helper(s,st,1,1);\n    }\n};"}