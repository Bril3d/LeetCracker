{"problemName":"number-of-good-paths","language":"cpp","code":"class UnionFind {\n    private:\n        vector<int> id, rank;\n        int cnt;\n    public:\n        UnionFind(int cnt) : cnt(cnt) {\n            id = vector<int>(cnt);\n            rank = vector<int>(cnt, 0);\n            for (int i = 0; i < cnt; ++i) id[i] = i;\n        }\n        int find(int p) {\n            if (id[p] == p) return p;\n            return id[p] = find(id[p]);\n        }\n        bool connected(int p, int q) { \n            return find(p) == find(q); \n        }\n        void connect(int p, int q) {\n            int i = find(p), j = find(q);\n            if (i == j) return;\n            if (rank[i] < rank[j]) {\n                id[i] = j;  \n            } else {\n                id[j] = i;\n                if (rank[i] == rank[j]) rank[j]++;\n            }\n            --cnt;\n        }\n};\n\nclass Solution {\npublic:\n    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {\n        int N = vals.size(), goodPaths = 0;\n        vector<vector<int>> adj(N);\n        map<int, vector<int>> sameValues;\n        \n        for (int i = 0; i < N; i++) {\n            sameValues[vals[i]].push_back(i);\n        }\n        \n        for (auto &e : edges) {\n            int u = e[0], v = e[1];\n            \n            if (vals[u] >= vals[v]) {\n                adj[u].push_back(v);\n            } else if (vals[v] >= vals[u]) {\n                adj[v].push_back(u);\n            }\n        }\n        \n        UnionFind uf(N);\n        \n        for (auto &[value, allNodes] : sameValues) {\n            \n            for (int u : allNodes) {\n                for (int v : adj[u]) {\n                    uf.connect(u, v);\n                }\n            }\n            \n            unordered_map<int, int> group;\n            \n            for (int u : allNodes) {\n                group[uf.find(u)]++;\n            }\n            \n            goodPaths += allNodes.size();\n            \n            for (auto &[_, size] : group) {\n                goodPaths += (size * (size - 1) / 2);\n            }\n        }\n        \n        return goodPaths;\n    }\n};"}